{
  "language": "Solidity",
  "sources": {
    "contracts/agreement-14-12-21.sol": {
      "content": "/*\r\n* Copyright (c) Siemens AG, 2020-2022\r\n*\r\n* Authors:\r\n*  Susanne Stahnke <susanne.stahnke@siemens.com>,\r\n*  Yvonne Kovacs <yvonne.kovacs@siemens.com> \r\n*\r\n* This work is licensed under the terms of Apache 2.0.  See\r\n* the LICENSE file in the top-level directory.\r\n*/\r\n\r\npragma solidity 0.8.9;\r\n\r\ncontract DataSharingAgreement {\r\n    enum State { Created, Active, Updated, Violated, Terminated }\r\n    enum ViolationType { DataIncomplete, DataIncorrect, DataTampered, KeyInvalid, PaymentTooMuch, PaymentIncorrect }\r\n\r\n    struct Agreement {\r\n        string dataOfferingId; \r\n        string purpose;\r\n        State state;\r\n        string providerId;\r\n        string consumerId;\r\n        uint256[3] agreementDates;\r\n        DescriptionOfData descriptionOfData;\r\n        IntendedUse intendedUse;\r\n        LicenseGrant licenseGrant;\r\n        bool dataStream;\r\n        bool signed;\r\n        Violation violation;\r\n    }\r\n\r\n    struct DescriptionOfData {\r\n        string dataType;\r\n        string dataFormat;\r\n        string dataSource;\r\n    }\r\n    \r\n    struct IntendedUse {\r\n        bool processData;\r\n        bool shareDataWithThirdParty;\r\n        bool editData;\r\n    }\r\n    \r\n    struct LicenseGrant {\r\n        bool copyData;\r\n        bool transferable;\r\n        bool exclusiveness;\r\n        bool revocable;\r\n    }\r\n    \r\n    struct Violation {\r\n        ViolationType violationType;\r\n        string issuerId;\r\n    }\r\n\r\n    Agreement[] public agreements;\r\n\r\n    uint256 activeAgreementCount;\r\n    mapping (string => uint) providerCount;\r\n    mapping (string => uint) consumerCount;\r\n\r\n    event AgreementCreated(string providerId, string consumerId, uint256 id);\r\n    event AgreementUpdated(string providerId, string consumerId, uint256 id);\r\n    event AgreementSigned(string providerId, string consumerId, uint256 id);\r\n    event AgreementTerminated(string providerId, string consumerId,uint256 id);\r\n\r\n    function createAgreement(\r\n                            string memory _dataOfferingId,\r\n                            string memory _purpose,\r\n                            string memory _providerId,\r\n                            string memory _consumerId,\r\n                            uint256[] memory dates,\r\n                            DescriptionOfData memory descriptionOfData,\r\n                            IntendedUse memory intendedUse,\r\n                            LicenseGrant memory licenseGrant,\r\n                            bool _dataStream) public {\r\n                            \r\n        Agreement memory newAgreement;\r\n        newAgreement.dataOfferingId = _dataOfferingId;\r\n        newAgreement.purpose = _purpose;\r\n        newAgreement.providerId = _providerId;\r\n        newAgreement.consumerId = _consumerId;\r\n    \r\n        newAgreement.state = State.Created;\r\n        newAgreement.agreementDates[0] = block.timestamp; \r\n        newAgreement.agreementDates[1] = dates[0];\r\n     \r\n        require ( dates[1] > newAgreement.agreementDates[0], \"End date must be after creation date.\" );\r\n        require ( dates[1] > dates[0], \"End date must be after start date.\" );\r\n        newAgreement.agreementDates[2] = dates[1];\r\n        \r\n        newAgreement.descriptionOfData.dataType = descriptionOfData.dataType;\r\n        newAgreement.descriptionOfData.dataFormat = descriptionOfData.dataFormat;\r\n        newAgreement.descriptionOfData.dataSource = descriptionOfData.dataSource;\r\n        \r\n        newAgreement.intendedUse.processData = intendedUse.processData;\r\n        newAgreement.intendedUse.shareDataWithThirdParty = intendedUse.shareDataWithThirdParty;\r\n        newAgreement.intendedUse.editData = intendedUse.editData;\r\n        \r\n        newAgreement.licenseGrant.copyData = licenseGrant.copyData;\r\n        newAgreement.licenseGrant.transferable = licenseGrant.transferable;\r\n        newAgreement.licenseGrant.exclusiveness = licenseGrant.exclusiveness;\r\n        newAgreement.licenseGrant.revocable = licenseGrant.revocable;\r\n        \r\n        newAgreement.dataStream = _dataStream;\r\n        \r\n        agreements.push(newAgreement);\r\n\r\n        providerCount[_providerId]++;\r\n        consumerCount[_consumerId]++;\r\n        \r\n        emit AgreementCreated(_providerId, _consumerId, agreements.length - 1);\r\n    }\r\n    \r\n    function updateAgreement(uint256 _id,\r\n                            string memory _dataOfferingId,\r\n                            string memory _purpose,\r\n                            string memory _providerId,\r\n                            string memory _consumerId,\r\n                            uint256[] memory dates,\r\n                            DescriptionOfData memory descriptionOfData,\r\n                            IntendedUse memory intendedUse,\r\n                            LicenseGrant memory licenseGrant,\r\n                            bool _dataStream) public {\r\n       \r\n        Agreement storage agreement = agreements[_id];   \r\n        if(agreement.state == State.Active)\r\n        {\r\n            agreement.dataOfferingId = _dataOfferingId;\r\n            agreement.purpose = _purpose;\r\n            agreement.providerId = _providerId; \r\n            agreement.consumerId = _consumerId;\r\n            agreement.agreementDates[1] = dates[0];\r\n     \r\n            require ( dates[1] > agreement.agreementDates[0], \"End date must be after creation date.\" );\r\n            require ( dates[1] > dates[0], \"End date must be after start date.\" );\r\n            agreement.agreementDates[2] = dates[1];\r\n        \r\n            agreement.descriptionOfData.dataType = descriptionOfData.dataType;\r\n            agreement.descriptionOfData.dataFormat = descriptionOfData.dataFormat;\r\n            agreement.descriptionOfData.dataSource = descriptionOfData.dataSource;\r\n        \r\n            agreement.intendedUse.processData = intendedUse.processData;\r\n            agreement.intendedUse.shareDataWithThirdParty = intendedUse.shareDataWithThirdParty;\r\n            agreement.intendedUse.editData = intendedUse.editData;\r\n        \r\n            agreement.licenseGrant.copyData = licenseGrant.copyData;\r\n            agreement.licenseGrant.transferable = licenseGrant.transferable;\r\n            agreement.licenseGrant.exclusiveness = licenseGrant.exclusiveness;\r\n            agreement.licenseGrant.revocable = licenseGrant.revocable;\r\n        \r\n            agreement.dataStream = _dataStream;\r\n\r\n            agreement.state = State.Updated;\r\n\r\n            emit AgreementUpdated(_providerId, _consumerId, _id);\r\n        }\r\n    }\r\n    \r\n    function signAgreement (uint256 id, string memory _consumerId) public {\r\n        require (keccak256(abi.encodePacked(agreements[id].consumerId)) == keccak256(abi.encodePacked(_consumerId)), \"Only the consumer of this agreement can sign.\" );\r\n    \r\n        agreements[id].signed = true;\r\n\r\n        if(agreements[id].agreementDates[2]>=block.timestamp) {\r\n            if(agreements[id].state == State.Created)\r\n                activeAgreementCount++;\r\n            agreements[id].state = State.Active;\r\n            emit AgreementSigned(agreements[id].providerId,_consumerId, id);\r\n        }\r\n        else{\r\n            agreements[id].state = State.Terminated;\r\n            activeAgreementCount--;\r\n            emit AgreementTerminated(agreements[id].providerId,_consumerId, id);\r\n        } \r\n    }\r\n\r\n    function getAgreement(uint256 id) public view returns (Agreement memory) {\r\n        return agreements[id];\r\n    }\r\n \r\n    function getAgreements() public view returns (Agreement[] memory) {\r\n        return agreements;\r\n    }\r\n\r\n     function getAgreementsLength() public view returns (uint256) {\r\n        return agreements.length;\r\n    } \r\n\r\n     function getState(uint256 id) public view returns (State) {\r\n        return agreements[id].state;\r\n    } \r\n    \r\n    function checkActiveAgreements () external view returns (Agreement[] memory) {\r\n        Agreement[] memory activeAgreements = new Agreement[](activeAgreementCount);\r\n        uint counter = 0;\r\n        for (uint i = 0; i < agreements.length; i++){\r\n            if(agreements[i].state == State.Active) {   \r\n                activeAgreements[counter] = agreements[i];\r\n                counter++;\r\n            }\r\n        }\r\n        return activeAgreements;\r\n    }\r\n    \r\n    function checkAgreementsByProvider (string memory _providerId) external view returns (Agreement[] memory) {\r\n        Agreement[] memory providerAgreements = new Agreement[](providerCount[_providerId]);\r\n        uint counter = 0;\r\n        for (uint i = 0; i < agreements.length; i++){\r\n            if (keccak256(abi.encodePacked(agreements[i].providerId)) == keccak256(abi.encodePacked(_providerId))) {\r\n                providerAgreements[counter] = agreements[i];\r\n                counter++;\r\n            }\r\n        }\r\n        return providerAgreements;\r\n    }\r\n    \r\n    function checkAgreementsByConsumer (string memory _consumerId) external view returns (Agreement[] memory) {\r\n        Agreement[] memory consumerAgreements = new Agreement[](consumerCount[_consumerId]);\r\n        uint counter = 0;\r\n        for (uint i = 0; i < agreements.length; i++){\r\n            if (keccak256(abi.encodePacked(agreements[i].consumerId)) == keccak256(abi.encodePacked(_consumerId))) {\r\n                consumerAgreements[counter] = agreements[i];\r\n                counter++;\r\n            }\r\n        }\r\n        return consumerAgreements;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}