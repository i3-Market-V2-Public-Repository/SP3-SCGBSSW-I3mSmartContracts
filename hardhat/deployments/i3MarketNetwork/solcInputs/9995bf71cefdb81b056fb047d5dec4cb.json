{
  "language": "Solidity",
  "sources": {
    "contracts/agreement.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.9;\n\ncontract DataSharingAgreement {\n    enum State { Created, Active, Terminated }\n    //enum Characteristic { Accuracy, Completeness, Reliability, Lawfulness, Updated }\n    \n    struct Agreement {\n        uint256 dataOfferingId; \n        string purpose;\n        State state;\n        string providerId;\n        string consumerId;\n        uint256 creationDate;\n        uint256 startDate;\n        uint256 endDate;\n        // Obligations obligations;\n        // DescriptionOfData descriptionOfData;\n        IntendedUse intendedUse;\n        LicenseGrant licenseGrant;\n        bool dataStream;\n        bool signed;\n    }\n    \n    // struct Obligations {\n    //     uint256 qualityOfData;\n    //     Characteristic characteristic;\n    //     bool dataAvailability;\n    // }\n    \n    struct DescriptionOfData {\n        string dataType;\n        string dataFormat;\n        string dataSource;\n    }\n    \n    struct IntendedUse {\n        bool processData;\n        bool shareDataWithThirdParty;\n        bool editData;\n    }\n    \n    struct LicenseGrant {\n        bool copyData;\n        bool transferable;\n        bool exclusiveness;\n        bool revocable;\n    }\n\n    Agreement[] public agreements;\n    \n    event AgreementCreated(string providerId, string consumerId, uint256 id);\n    event AgreementUpdated(string providerId, string consumerId, uint256 id);\n    event AgreementSigned(uint256 id);\n    \n    function createAgreement(\n                            uint256 _dataOfferingId,\n                            string memory _purpose,\n                            string memory _providerId,\n                            string memory _consumerId,\n                            uint256[] memory dates,\n                            // Obligations memory obligations,\n                            // DescriptionOfData memory descriptionOfData,\n                            IntendedUse memory intendedUse,\n                            LicenseGrant memory licenseGrant,\n                            bool _dataStream) public {\n                            \n        Agreement memory newAgreement;\n        newAgreement.dataOfferingId = _dataOfferingId;\n        newAgreement.purpose = _purpose;\n        newAgreement.providerId = _providerId;\n        newAgreement.consumerId = _consumerId;\n    \n        newAgreement.state = State.Created;\n        newAgreement.creationDate = block.timestamp; \n        if(dates[0] <= newAgreement.creationDate) newAgreement.state = State.Active;\n        newAgreement.startDate = dates[0];\n     \n        require ( dates[1] > newAgreement.creationDate, \"End date must be after creation date.\" );\n        require ( dates[1] > dates[0], \"End date must be after start date.\" );\n        newAgreement.endDate = dates[1];\n        \n        // newAgreement.obligations.qualityOfData = obligations.qualityOfData;\n        // newAgreement.obligations.characteristic = obligations.characteristic;\n        // newAgreement.obligations.dataAvailability = obligations.dataAvailability;\n        \n        // newAgreement.descriptionOfData.dataType = descriptionOfData.dataType;\n        // newAgreement.descriptionOfData.dataFormat = descriptionOfData.dataFormat;\n        // newAgreement.descriptionOfData.dataSource = descriptionOfData.dataSource;\n        \n        newAgreement.intendedUse.processData = intendedUse.processData;\n        newAgreement.intendedUse.shareDataWithThirdParty = intendedUse.shareDataWithThirdParty;\n        newAgreement.intendedUse.editData = intendedUse.editData;\n        \n        newAgreement.licenseGrant.copyData = licenseGrant.copyData;\n        newAgreement.licenseGrant.transferable = licenseGrant.transferable;\n        newAgreement.licenseGrant.exclusiveness = licenseGrant.exclusiveness;\n        newAgreement.licenseGrant.revocable = licenseGrant.revocable;\n        \n        newAgreement.dataStream = _dataStream;\n        \n        agreements.push(newAgreement);\n        \n        emit AgreementCreated(_providerId, _consumerId, agreements.length - 1);\n    }\n    \n    function updateAgreement(uint256 _id,\n                            uint256 _dataOfferingId,\n                            string memory _purpose,\n                            string memory _providerId,\n                            string memory _consumerId,\n                            uint256[] memory dates,\n                            // DescriptionOfData memory descriptionOfData,\n                            IntendedUse memory intendedUse,\n                            LicenseGrant memory licenseGrant,\n                            bool _dataStream) public {\n        \n \n        Agreement storage agreement = agreements[_id];   \n        agreement.dataOfferingId = _dataOfferingId;\n        agreement.purpose = _purpose;\n        agreement.providerId = _providerId; \n        agreement.consumerId = _consumerId;\n        \n        if(dates[0] <= block.timestamp) agreement.state = State.Active;\n        agreement.startDate = dates[1];\n     \n        require ( dates[1] > agreement.creationDate, \"End date must be after creation date.\" );\n        require ( dates[1] > dates[0], \"End date must be after start date.\" );\n        agreement.endDate = dates[1];\n        \n        // agreement.descriptionOfData.dataType = descriptionOfData.dataType;\n        // agreement.descriptionOfData.dataFormat = descriptionOfData.dataFormat;\n        // agreement.descriptionOfData.dataSource = descriptionOfData.dataSource;\n        \n        agreement.intendedUse.processData = intendedUse.processData;\n        agreement.intendedUse.shareDataWithThirdParty = intendedUse.shareDataWithThirdParty;\n        agreement.intendedUse.editData = intendedUse.editData;\n        \n        agreement.licenseGrant.copyData = licenseGrant.copyData;\n        agreement.licenseGrant.transferable = licenseGrant.transferable;\n        agreement.licenseGrant.exclusiveness = licenseGrant.exclusiveness;\n        agreement.licenseGrant.revocable = licenseGrant.revocable;\n        \n        agreement.dataStream = _dataStream;\n        \n        emit AgreementUpdated(_providerId, _consumerId, _id);\n    }\n    \n    function signAgreement (uint256 id, string memory _consumerId) public {\n        require (keccak256(abi.encodePacked(agreements[id].consumerId)) == keccak256(abi.encodePacked(_consumerId)), \"Only the consumer of this agreement can sign.\" );\n       \n        agreements[id].signed = true;\n        emit AgreementSigned(id);\n    }\n \n    \n    function getAgreement(uint256 id) public view returns (Agreement memory) {\n        Agreement storage fetchedAgreement = agreements[id];\n        return (fetchedAgreement);\n    }\n    \n    function getState(uint256 id) public view returns (State) {\n        Agreement storage fetchedAgreement = agreements[id];\n        return (fetchedAgreement.state);\n    } \n    \n    function checkActiveAgreements () external view returns (Agreement[] memory) {\n        Agreement[] memory activeAgreements;\n        uint counter = 0;\n        for (uint i = 0; i < agreements.length; i++)\n            if(agreements[i].state == State.Active) {   \n                activeAgreements[counter] = agreements[i];\n                counter++;\n            }\n        return activeAgreements;\n    }\n    \n    function checkAgreementsByProvider (string memory _providerId) external view returns (Agreement[] memory) {\n        Agreement[] memory providerAgreements;\n        uint counter = 0;\n        for (uint i = 0; i < agreements.length; i++)\n            if (keccak256(abi.encodePacked(agreements[i].providerId)) == keccak256(abi.encodePacked(_providerId))) {\n                providerAgreements[counter] = agreements[i];\n                counter++;\n            }\n        return providerAgreements;\n    }\n    \n    function checkAgreementsByConsumer (string memory _consumerId) external view returns (Agreement[] memory) {\n        Agreement[] memory consumerAgreements;\n        uint counter = 0;\n        for (uint i = 0; i < agreements.length; i++)\n            if (keccak256(abi.encodePacked(agreements[i].consumerId)) == keccak256(abi.encodePacked(_consumerId))) {\n                consumerAgreements[counter] = agreements[i];\n                counter++;\n            }\n        return consumerAgreements;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}