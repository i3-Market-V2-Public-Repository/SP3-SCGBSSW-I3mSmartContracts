{
    "language": "Solidity",
    "sources": {
      "contracts/Agreement.sol": {
        "content": "// /*\r\n\r\n// * Copyright (c) Siemens AG, 2020-2022\r\n\r\n// *\r\n\r\n// * Authors:\r\n\r\n// * Susanne Stahnke <susanne.stahnke@siemens.com>,\r\n\r\n// * Yvonne Kovacs <yvonne.kovacs@siemens.com>\r\n\r\n// *\r\n\r\n// * This work is licensed under the terms of Apache 2.0. See\r\n\r\n// * the LICENSE file in the top-level directory.\r\n\r\n// */\r\n\r\npragma solidity ^0.8.0;\r\n\r\nenum State {\r\n    Active,\r\n    Violated,\r\n    Terminated\r\n}\r\n\r\nstruct Agreement {\r\n    uint256 agreementId;\r\n    string providerPublicKey;\r\n    string consumerPublicKey;\r\n    string dataExchangeAgreementHash;\r\n    string[2] signatures;\r\n    DataOffering dataOffering;\r\n    string purpose;\r\n    State state;\r\n    uint256[3] agreementDates;\r\n    IntendedUse intendedUse;\r\n    LicenseGrant licenseGrant;\r\n    TypeOfData typeOfData;\r\n    PricingModel pricingModel;\r\n    Violation violation;\r\n}\r\n\r\nstruct TypeOfData {\r\n    bool dataStream;\r\n    bool personalData;\r\n}\r\n\r\nstruct DataOffering {\r\n    string dataOfferingId;\r\n    uint256 dataOfferingVersion;\r\n    string title;\r\n}\r\n\r\nstruct IntendedUse {\r\n    bool processData;\r\n    bool shareDataWithThirdParty;\r\n    bool editData;\r\n}\r\n\r\nstruct LicenseGrant {\r\n    bool transferable;\r\n    bool exclusiveness;\r\n    bool paidUp;\r\n    bool revocable;\r\n    bool processing;\r\n    bool modifying;\r\n    bool analyzing;\r\n    bool storingData;\r\n    bool storingCopy;\r\n    bool reproducing;\r\n    bool distributing;\r\n    bool loaning;\r\n    bool selling;\r\n    bool renting;\r\n    bool furtherLicensing;\r\n    bool leasing;\r\n}\r\n\r\nstruct PricingModel {\r\n    string paymentType;\r\n    uint256 price;\r\n    string currency;\r\n    uint256 fee;\r\n    PaymentOnSubscription paymentOnSubscription;\r\n    bool isFree;\r\n}\r\n\r\nstruct PaymentOnSubscription {\r\n    string timeDuration;\r\n    string repeat;\r\n}\r\n\r\nenum ViolationType {\r\n    NotViolated,\r\n    PaymentNotCompleted,\r\n    DataNotTransferredAsDescribed,\r\n    DataNotAsDescribed,\r\n    LicenseViolated\r\n}\r\n\r\nstruct Violation {\r\n    ViolationType violationType;\r\n    string issuerId;\r\n    string[3] penaltyChoices;\r\n}\r\n\r\n\r\nstruct SignedResolution {\r\n    string proofType;\r\n    string resolutionType;\r\n    string resolution;\r\n    string dataExchangeId;\r\n    uint256 iat;\r\n    string iss;\r\n    string sub;\r\n}\r\n\r\nlibrary AgreementViolationLibrary {\r\n\r\n    function evaluateResolution(\r\n        Agreement storage agreement,\r\n        string memory _proofType,\r\n        string memory _type,\r\n        string memory _resolution,\r\n        string memory _dataExchangeId,\r\n        uint256 _iat,\r\n        string memory _iss,\r\n        string memory _sub) public{ \r\n\r\n        SignedResolution memory signedResolution = SignedResolution( _proofType, _type, _resolution, _dataExchangeId, _iat, _iss, _sub);\r\n\r\n        if(keccak256(abi.encodePacked(signedResolution.resolution)) == keccak256(abi.encodePacked(\"completed\"))){\r\n            delete agreement.violation;\r\n            agreement.state = State.Active;   \r\n        }\r\n        else if(keccak256(abi.encodePacked(signedResolution.resolution)) == keccak256(abi.encodePacked(\"notCompleted\"))) { \r\n                issueViolation(agreement, ViolationType.DataNotTransferredAsDescribed, signedResolution.sub); \r\n                agreement.state = State.Violated;    \r\n        }\r\n        else if(keccak256(abi.encodePacked(signedResolution.resolution)) == keccak256(abi.encodePacked(\"accepted\"))){ \r\n                issueViolation(agreement, ViolationType.DataNotTransferredAsDescribed, signedResolution.sub); \r\n                agreement.state = State.Violated; \r\n             }\r\n        else if(keccak256(abi.encodePacked(signedResolution.resolution)) == keccak256(abi.encodePacked(\"denied\"))){\r\n                delete agreement.violation; \r\n                agreement.state = State.Active; \r\n        }\r\n    }\r\n\r\n    function issueViolation(Agreement storage agreement, ViolationType _violationType, string memory _issuerId) private {\r\n        agreement.violation = Violation(_violationType, _issuerId, [\"Terminate\", \"NewEndDateForAgreement\", \"NewEndDateForAgreementAndReductionOfPayment\"]);\r\n    }\r\n\r\n     function getViolation(Agreement storage agreement) public view returns (Violation memory){\r\n        return agreement.violation;\r\n    }\r\n   \r\n    function enforcePenalty (Agreement storage agreement, string memory _chosenPenalty, uint256 _price, uint256 _fee,\r\n                             uint256 _newEndDate) public returns (Agreement storage) {\r\n\r\n        if(agreement.violation.violationType == ViolationType.DataNotTransferredAsDescribed){\r\n                if (keccak256(abi.encodePacked(_chosenPenalty)) == \"NewEndDateForAgreement\"){\r\n                    require(_newEndDate > block.timestamp, \"New end date must be after current date\");\r\n                    agreement.agreementDates[2] = _newEndDate;\r\n                }\r\n                else if (keccak256(abi.encodePacked(_chosenPenalty)) == (keccak256(abi.encodePacked(\"NewEndDateForAgreementAndReductionOfPayment\")))){\r\n                    require(_newEndDate > block.timestamp, \"New end date must be after current date.\");\r\n                    agreement.agreementDates[2] = _newEndDate;\r\n                    agreement.pricingModel.price = _price;\r\n                    agreement.pricingModel.fee = _fee;\r\n                }\r\n            agreement.state = State.Active;\r\n        }  \r\n        return agreement;  \r\n    }\r\n}\r\n    \r\n\r\ncontract DataSharingAgreement {\r\n    \r\n    using AgreementViolationLibrary for Agreement;\r\n  \r\n    uint256 agreementId;\r\n\r\n    mapping (string => bool) isPublicKeyProvider;\r\n    mapping (string => bool) isPublicKeyConsumer;\r\n\r\n    mapping (uint256 => Agreement) agreements;\r\n    mapping (string => uint256) consumerKey2agreementId;\r\n    mapping (string => uint256) providerKey2agreementId;\r\n    mapping (string => uint256[]) offeringId2agreementIds;\r\n\r\n    event AgreementActive(string providerPublicKey, string consumerPublicKey, uint256 id);\r\n    event PenaltyChoices(string consumerPublicKey, uint256 id, string[3] penaltyChoices);\r\n    event AgreeOnPenalty(string providerPublicKey, string consumerPublicKey, uint256 id, string chosenPenalty, uint256 newEndDate, uint256 price, uint256 fee);\r\n    event AgreementTerminated(string providerPublicKey, string consumerPublicKey,uint256 id);\r\n\r\n    function createAgreement(\r\n        string memory _providerPublicKey,\r\n        string memory _consumerPublicKey,\r\n        string memory _dataExchangeAgreementHash,\r\n        string[2] memory _signatures,\r\n        DataOffering memory dataOffering,\r\n        string memory _purpose,\r\n        uint256[3] memory dates,\r\n        IntendedUse memory intendedUse,\r\n        LicenseGrant memory licenseGrant,\r\n        PricingModel memory pricingModel,\r\n        TypeOfData memory typeOfData\r\n    ) public {\r\n        require (isPublicKeyProvider[_providerPublicKey] == false, \"Provider pK should be unique.\");\r\n        require (isPublicKeyConsumer[_consumerPublicKey] == false, \"Consumer pK should be unique.\");\r\n        require(dates[1] >= dates[0], \"Start date must be after creation date.\");\r\n        require(dates[2] > dates[1], \"End date must be after start date.\");\r\n\r\n        agreementId++; \r\n        agreements[agreementId] = Agreement(\r\n             agreementId,\r\n            _providerPublicKey,\r\n            _consumerPublicKey,\r\n            _dataExchangeAgreementHash,\r\n            _signatures,\r\n            dataOffering,\r\n            _purpose,\r\n            State.Active,\r\n            dates,\r\n            intendedUse,\r\n            licenseGrant,\r\n            typeOfData,\r\n            pricingModel,\r\n            Violation(ViolationType.NotViolated,\"\",[\"\",\"\",\"\"])   \r\n        );\r\n        \r\n        consumerKey2agreementId[_consumerPublicKey] = agreementId;\r\n        providerKey2agreementId[_providerPublicKey] = agreementId;\r\n        offeringId2agreementIds[dataOffering.dataOfferingId].push(agreementId);\r\n        \r\n        isPublicKeyProvider[_providerPublicKey] = true;\r\n        isPublicKeyConsumer[_consumerPublicKey] = true;\r\n\r\n        emit AgreementActive(_providerPublicKey, _consumerPublicKey, agreementId);\r\n    }\r\n\r\n    function getAgreement(uint256 id) public view returns (Agreement memory) {\r\n        return agreements[id];\r\n    }\r\n\r\n    function retrievePricingModel(uint256 _agreementId) public view returns (PricingModel memory){\r\n        return agreements[_agreementId].pricingModel;\r\n    }\r\n\r\n    function getState(uint256 id) public view returns (State) {\r\n        return agreements[id].state;\r\n    } \r\n\r\n    function getAgreementsByConsumer(string memory _consumerPublicKey, bool active) external view returns (Agreement memory consumerAgreement) {\r\n       Agreement memory agreement = agreements[consumerKey2agreementId[_consumerPublicKey]];\r\n       if(active){\r\n            if(agreement.state == State.Active)\r\n                        return agreement;     \r\n       } \r\n       else\r\n            return agreement;\r\n    }\r\n\r\n    function getAgreementsByProvider(string memory _providerPublicKeys, bool active) public view returns(Agreement memory providerAgreement) {\r\n        Agreement memory agreement = agreements[providerKey2agreementId[_providerPublicKeys]];\r\n        if(active){\r\n            if (agreement.state == State.Active)\r\n                return agreement;\r\n        }\r\n        else \r\n            return agreement;\r\n    }\r\n\r\n    function checkAgreementsByDataOffering(string memory _dataOfferingId) public view returns(uint256[] memory) {\r\n       return offeringId2agreementIds[_dataOfferingId];\r\n    }\r\n\r\n    function evaluateSignedResolution(uint256 _agreementId, string memory _proofType, string memory _type, string memory _resolution,\r\n                                string memory _dataExchangeId, uint256 _iat, string memory _iss, string memory _sub) public{ \r\n\r\n      AgreementViolationLibrary.evaluateResolution(agreements[_agreementId], _proofType, _type, _resolution, _dataExchangeId, _iat, _iss, _sub);\r\n      emit PenaltyChoices(agreements[_agreementId].consumerPublicKey, _agreementId, agreements[_agreementId].violation.penaltyChoices);\r\n    }\r\n\r\n    function terminateAgreement(uint256 _agreementId, bool terminate) public{ \r\n      if(agreements[_agreementId].agreementDates[2]<=block.timestamp || terminate){  \r\n            agreements[_agreementId].state = State.Terminated;\r\n            emit AgreementTerminated(agreements[_agreementId].providerPublicKey, agreements[_agreementId].consumerPublicKey, _agreementId); \r\n        }\r\n    }\r\n\r\n    function enforcePenalty ( uint256 _id, string memory _chosenPenalty, uint256 _price, uint256 _fee, uint256 _newEndDate) public {\r\n        require((agreements[_id].state == State.Violated), \"Agreement must be violated in order to enforce penalty\");\r\n        if(keccak256(abi.encodePacked(_chosenPenalty)) == keccak256(abi.encodePacked(\"Terminate\"))){\r\n            terminateAgreement(_id, true);\r\n        }\r\n        else{\r\n            AgreementViolationLibrary.enforcePenalty (agreements[_id], _chosenPenalty, _price, _fee, _newEndDate);\r\n            emit AgreeOnPenalty(agreements[_id].providerPublicKey, agreements[_id].consumerPublicKey,\r\n                 agreements[_id].agreementId, _chosenPenalty, _newEndDate,_price, _fee);\r\n        }\r\n    }\r\n\r\n    function notifyConsentRevoked( string memory _dataOfferingId) public view returns (string[] memory) {    \r\n\r\n        uint256[] memory agreementIds = offeringId2agreementIds[_dataOfferingId];\r\n       \r\n        string[] memory consumers = new string[](agreementIds.length);\r\n        for (uint i = 0; i < agreementIds.length; i++){\r\n            consumers[i] = agreements[agreementIds[i]].consumerPublicKey;\r\n        }\r\n        return consumers;\r\n    }\r\n}\r\n"
      },
      "contracts/ExplicitUserConsent.sol": {
        "content": "// /*\r\n\r\n// * Copyright (c) Siemens AG, 2020-2022\r\n\r\n// *\r\n\r\n// * Authors:\r\n\r\n// * Susanne Stahnke <susanne.stahnke@siemens.com>,\r\n\r\n// * Yvonne Kovacs <yvonne.kovacs@siemens.com>\r\n\r\n// *\r\n\r\n// * This work is licensed under the terms of Apache 2.0. See\r\n\r\n// * the LICENSE file in the top-level directory.\r\n\r\n// */\r\n\r\nimport \"./Agreement.sol\";\r\n\r\ncontract ExplicitUserConsent {\r\n\r\n    struct Consent {\r\n        string dataOfferingId;\r\n        string consentSubject;\r\n        address consentOperator;\r\n        string consentFormHash;\r\n        uint256 startDate;\r\n        uint256 endDate;\r\n        uint256 status;\r\n    }\r\n\r\n    mapping(string => Consent[]) consents;\r\n\r\n    event ConsentGiven(string dataOfferingId, string[] consentSubjects);\r\n    event ConsentRevoked(string[] consumers, string dataOfferingId, string[] consentSubjects);\r\n\r\n    function giveConsent(\r\n        string memory _dataOfferingId,\r\n        string[] memory _consentSubjects,\r\n        string memory _consentFormHash,\r\n        uint256 _startDate,\r\n        uint256 _endDate\r\n    ) public {\r\n        require(_startDate>=block.timestamp);\r\n        require(_endDate>=_startDate);\r\n        for(uint256 i=0; i< _consentSubjects.length; i++) {\r\n            \r\n            consents[_dataOfferingId].push(Consent(_dataOfferingId,_consentSubjects[i], msg.sender, _consentFormHash,_startDate,_endDate, _endDate));\r\n        }\r\n        emit ConsentGiven(_dataOfferingId, _consentSubjects);\r\n    }\r\n\r\n\r\n    function checkConsentStatus(string memory _dataOfferingId, string memory _consentSubject)\r\n        external\r\n        view\r\n        returns (uint256[] memory) \r\n    {\r\n        Consent[] memory consentsByDataOffering = consents[_dataOfferingId];\r\n        uint256 length = consentsByDataOffering.length;\r\n        uint256[] memory consentsStatus;\r\n        uint256 k = 0;\r\n\r\n        bytes memory emptyString = bytes(_consentSubject); \r\n        if (emptyString.length == 0) {\r\n            consentsStatus = new uint256[](length);\r\n            for (uint256 i = 0; i < length; i++) {                 \r\n                if (block.timestamp > consentsByDataOffering[i].endDate){ \r\n                    consentsByDataOffering[i].status = 0; \r\n                }\r\n                 consentsStatus[k++] = consentsByDataOffering[i].status;\r\n            }\r\n        }\r\n        else {\r\n            consentsStatus = new uint256[](1);\r\n            for (uint256 i = length-1; i >= 0; i--) {\r\n                if (block.timestamp > consentsByDataOffering[i].endDate){\r\n                    consentsByDataOffering[i].status = 0; \r\n                }\r\n                if(keccak256(abi.encodePacked(consentsByDataOffering[i].consentSubject)) == keccak256(abi.encodePacked(_consentSubject))){\r\n                    consentsStatus[k++] = consentsByDataOffering[i].status;\r\n                    break;\r\n                }\r\n            }       \r\n        }\r\n        \r\n        return consentsStatus;\r\n    }\r\n\r\n    function revokeConsent( address _addr, string memory _dataOfferingId, string[] memory _consentSubjects) public {\r\n\r\n        Consent[] memory consentsByDataOffering = consents[_dataOfferingId];\r\n        uint256 length = consentsByDataOffering.length;\r\n        if (_consentSubjects.length == 0) {\r\n            for (uint256 i = 0; i < length; i++) {\r\n                require(consents[_dataOfferingId][i].consentOperator == msg.sender);\r\n                consents[_dataOfferingId][i].status = 0;\r\n            }\r\n        } else {\r\n            for (uint256 i = 0; i < length; i++) {\r\n                require(consents[_dataOfferingId][i].consentOperator == msg.sender);\r\n                for (uint256 j = 0; j < _consentSubjects.length; j++)\r\n                    if (keccak256(abi.encodePacked(consentsByDataOffering[i].consentSubject)) == keccak256(abi.encodePacked(_consentSubjects[j])))\r\n                        consents[_dataOfferingId][i].status = 0;\r\n            }\r\n        }\r\n\r\n        DataSharingAgreement agreement = DataSharingAgreement(_addr);\r\n\r\n        string[] memory consumers = agreement.notifyConsentRevoked(_dataOfferingId);\r\n\r\n        emit ConsentRevoked(consumers, _dataOfferingId, _consentSubjects);\r\n    }\r\n}\r\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 500
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata",
            "devdoc",
            "userdoc",
            "storageLayout",
            "evm.gasEstimates"
          ],
          "": [
            "ast"
          ]
        }
      },
      "metadata": {
        "useLiteralContent": true
      }
    }
  }